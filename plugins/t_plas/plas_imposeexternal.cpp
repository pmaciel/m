
#include "common.h"


/*
 * This file contains routines for the generation of entities,
 * be it to form an initial set of entities or to create
 * entites due to secondary phase boundary conditions.
 *
 * This function imposes entities that were generated by an
 * external code module (e.g. electrochemistry).
 */

void plas_ImposeExternal(PLAS_DATA *data)
{
  LOCAL_ENTITY_VARIABLES ent;
  LOCAL_FLOW_VARIABLES flow;
  int numProc = plas_MpiGetNumProc();
  int *disps  = new int[numProc];
  int *recs   = new int[numProc];
  int ient,idim,totNewEnt;
  double *newPos,*newVel,*newDiam,*newTemp;

#ifdef MPI
  int iproc;
  int *dispsArr = new int[numProc];
  int *recsArr  = new int[numProc];
#endif

  //***Allocation of local data structure***//

  plas_AllocateLocalEntityVar(data->fp.numDim,&ent);
  plas_AllocateLocalFlowVar(data->fp.numDim,&flow);

  //***Broadcast entity data***//

  totNewEnt = plas_MpiAllSumInt(data->numExtEnt);
  newDiam = new double[totNewEnt];
  newTemp = new double[totNewEnt];
  newPos  = new double[totNewEnt*data->fp.numDim];
  newVel  = new double[totNewEnt*data->fp.numDim];

#ifdef MPI
  MPI_Allgather(&data->numExtEnt,1,MPI_INT,recs,1,MPI_INT,MPI_COMM_WORLD);

  disps[0] = 0;
  for(iproc=1; iproc<numProc; iproc++){
    disps[iproc] = disps[iproc-1] + recs[iproc-1];
  }

  for(iproc=0; iproc<numProc; iproc++){
    recsArr[iproc] = data->fp.numDim*recs[iproc];
    dispsArr[iproc] = data->fp.numDim*disps[iproc];
  }

  MPI_Allgatherv(data->extEntDiam,data->numExtEnt,MPI_DOUBLE,newDiam,recs,disps,MPI_DOUBLE,MPI_COMM_WORLD);
  MPI_Allgatherv(data->extEntTemp,data->numExtEnt,MPI_DOUBLE,newTemp,recs,disps,MPI_DOUBLE,MPI_COMM_WORLD);
  MPI_Allgatherv(data->extEntPos,data->numExtEnt*data->fp.numDim,MPI_DOUBLE,newPos,recsArr,dispsArr,MPI_DOUBLE,MPI_COMM_WORLD);
  MPI_Allgatherv(data->extEntVel,data->numExtEnt*data->fp.numDim,MPI_DOUBLE,newVel,recsArr,dispsArr,MPI_DOUBLE,MPI_COMM_WORLD);
#else
  newDiam = data->extEntDiam;
  newTemp = data->extEntTemp;
  newPos = data->extEntPos;
  newVel = data->extEntVel;
#endif

  //***Loop over entities to generate***//

  for(ient=0; ient<totNewEnt; ient++){

    for(idim=0; idim<data->fp.numDim; idim++){
      ent.pos[idim] = newPos[data->fp.numDim*ient+idim];
    }
    for(idim=0; idim<data->fp.numDim; idim++){
      ent.vel[idim] = newVel[data->fp.numDim*ient+idim];
    }
    ent.diam = newDiam[ient];
    ent.temp = newTemp[ient];

    //***Element search***//

    plas_SearchDomainParallel(data,&ent);

    //***Initialize entity***//

    if(ent.flag==DFLAG_ENABLED && data->sd.enabled<data->ip.numMaxEnt){

      plas_SetElementGeometry(data->fp.numDim,&ent);
      plas_Interpolate(data,&ent,&flow,0.0);

      data->ed[data->sd.enabled].flag = DFLAG_CREATED;
      data->ed[data->sd.enabled].element = ent.elm;
      data->ed[data->sd.enabled].node = plas_FindNearestElementNode(data,&ent);
      data->ed[data->sd.enabled].diameter = ent.diam;
      data->ed[data->sd.enabled].temperature = ent.temp;
      for(idim=0; idim<data->fp.numDim; idim++){
        data->ed[data->sd.enabled].position[idim] = ent.pos[idim];
        data->ed[data->sd.enabled].velocity[idim] = flow.vel[idim]+ent.vel[idim];
      }
      data->sd.enabled++;
      data->sd.in++;
    }
  }

  //***De-allocation of local data structure***//

  plas_DeallocateLocalEntityVar(&ent);
  plas_DeallocateLocalFlowVar(data->fp.numDim,&flow);

  delete[] newDiam;
  delete[] newTemp;
  delete[] newPos;
  delete[] newVel;
  delete[] disps;
  delete[] recs;
}

