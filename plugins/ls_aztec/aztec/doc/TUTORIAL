                          AZTEC Tutorial

A sample AZTEC application is provided in the file 'az_simple.c'. The 11 
exercises below are performed by continually modifying the sample program. 
By doing the exercises, the new user will be introduced to many of AZTEC's
features.  Unless otherwise stated, problem x will require modification to 
the program used for problem x-1. Complete answers to the exercises are
given at the end of this document.

To compile and run the original sample program, the SRC_C line in the 
application Makefile must be changed to : SRC_C = az_simple.c. 'az_simple.c' 
corresponds to setting up and solving a 2D Poisson approximation on a 6 x 6 
grid where the right hand side corresponds to a delta function in the lower 
left corner of the grid. Below we illustrate the program body:

line no.
-------

 42    /* get number of processors and the name of this processor */
 43 
 44    AZ_processor_info(proc_config);
 45 
 46    /* Define partitioning:matrix rows (ascending order) owned by this node */
 47 
 48    AZ_read_update(&N_update,&update,proc_config,n*n,1,AZ_linear);
 49 
 50    /* create the matrix: each processor creates only rows  */
 51    /* appearing in update[] (using global col. numbers).   */
 52 
 53    bindx   = (int    *) calloc(N_update*5+1,sizeof(int));
 54    val     = (double *) calloc(N_update*5+1,sizeof(double));
 55    if (val == NULL) perror("Error: Not enough space to create matrix")
 56 
 57    bindx[0] = N_update+1;
 58    for (i = 0 ; i < N_update ; i++ ) {
 59       add_row(update[i],i,val,bindx);
 60    }
 61 
 62    /* convert matrix to a local distributed matrix */
 63  
 64    AZ_transform(proc_config,&external,bindx,val,update,&update_index,
 65         &extern_index,&data_org,N_update,NULL,NULL,NULL,NULL,AZ_MSR_MATRIX);
 66 
 67    /* initialize AZTEC options */
 68 
 69    AZ_defaults(options, params);
 70 
 71   /* Set rhs (delta function at lower left corner) and initialize guess */
 72 
 73   b = (double *) calloc(N_update,sizeof(double));
 74   x = (double *) calloc(N_update + data_org[AZ_N_external],sizeof(double));
 75   if ((x == NULL) && (i != 0)) perror("Not enough space in rhs")
 76 
 77   for (i=0 ; i < N_update; i++ ) { 
 78     x[update_index[i]] = 0.0;
 79     b[update_index[i]] = 0.0;
 80     if (update[i] == 0    ) b[update_index[i]] = 1.0;
 81   }
 82 
 83   /* solve the system of equations using b  as the right hand side */
 84 
 85    AZ_solve(x,b, options, params, NULL,bindx,NULL,NULL,NULL,val,
 86 	    data_org, status, proc_config);
 87 
 88 #ifdef MPI
 89    MPI_Finalize();
 90 #endif
 91 }
 92 
 93 /***************************************************************************/
 94 /***************************************************************************/
 95 
 96 void add_row(int row,int location,double val[], int bindx[])
 97 {
 98 /* Add one row to an MSR matrix corresponding to a discrete approximation
 99  * to the 2D Poisson operator on an n x n square.
100  *
101  * Parameters:
102  *    row          == global row number of the new row to be added.
103  *    location     == local row where diagonal of the new row will be stored.
104  *    val,bindx    == (see user's guide). On output, val[] and bindx[] 
105  *                    are appended such that the new row has been added.
106  */
107    int k;
108 
109    /* check neighbors in each direction and add nonzero if neighbor exits */
110 
111    k = bindx[location];
112    bindx[k]  = row + 1;   if ((row  )%n != n-1) val[k++] = -1.;
113    bindx[k]  = row - 1;   if ((row  )%n !=   0) val[k++] = -1.;
114    bindx[k]  = row + n;   if ((row/n)%n != n-1) val[k++] = -1.;
115    bindx[k]  = row - n;   if ((row/n)%n !=   0) val[k++] = -1.;
116 
117    bindx[location+1] = k;  val[location]     = 4.; /* matrix diagonal */
118 }
   
If you run this program, the iteration output should approximately be the 
following:

                *******************************************************
                ***** Preconditioned GMRES solution
                ***** No preconditioning
                ***** No scaling
                *******************************************************
 
                iter:    0              residual = 1.000000e+00
                iter:    1              residual = 3.333333e-01
                iter:    2              residual = 1.549193e-01
                iter:    3              residual = 8.498208e-02
                iter:    4              residual = 5.178089e-02
                iter:    5              residual = 3.392084e-02
                iter:    6              residual = 2.343361e-02
                iter:    7              residual = 1.673219e-02
                iter:    8              residual = 1.183812e-02
                iter:    9              residual = 7.732077e-03
                iter:   10              residual = 4.398328e-03
                iter:   11              residual = 1.241776e-03
                iter:   12              residual = 5.528073e-04
                iter:   13              residual = 1.918082e-04
                iter:   14              residual = 6.826307e-05
                iter:   15              residual = 1.470372e-05
                iter:   16              residual = 3.001987e-06
                iter:   17              residual = 2.111772e-07
 
---

IMPORTANT: SAVE A COPY OF THIS PROGRAM IN THE FILE 'original.c'.

Problem 1:
==========
To partition or distribute problems over processors, each processor
must set 'N_update' to the number of matrix rows it will own and the 
array 'update' to the specific matrix row numbers (in ascending order)
owned by this processor. In our sample program, a linear partitioning is 
used via the function AZ_read_update() (line 48).

Change the AZ_read_update() call so that it instead reads the paritioning
from the file '.update'. Initialize this file so that the row r (0 <= r < 36)
is assigned to processor number r%P (mod function in "C") where P is
the number of processors used with this '.update' file. 

Note: AZ_read_update() is not particularly fast in that it reads a 
single file and thus distributes rows serially. For large data sets
it is generally better to use some kind of parallel input/output.
See the AZ_read_update() description in the Aztec User's Guide for 
more information.

The output of this program should be the same as that of the original
sample problem as we have only changed the assignment of rows to processors.  

Problem 2:
==========
IMPORTANT: COPY THE FILE 'original.c' INTO 'az_simple.c'. YOU MIGHT WANT 
TO SAVE 'az_simple.c' BEFORE DOING THIS.

Change this program to solve the matrix application

   /              \        / \
   |  7  3  2  1  |       | 1 |  
   |  5  8  3  1  |  x  = | 0 |
   |  5  3  9  2  |       | 0 |
   |  1  2  1  6  |       | 0 |
   \              /       \   /

Using x = 0 as an initial guess.

Hint: Change AZ_read_update() in line 48 to indicate the number of 
matrix rows. Other than this, only the subroutine add_row() needs to 
be changed. The "Data Formats" and "High Level Data Interface" sections 
of the Aztec User's Guide explain the MSR data format used to represent 
the matrix. Essentially, to append a row to a matrix already containing 
j rows (rows are locally numbered from 0 to j-1), we need to do the 
following:

   a) set index, k, to point to the free space for the offdiagonal elements:
      k = bindx[j]

   b) Store each off diagonal element as follows:

         val[k] = 1st off-diagonal, bindx[k] = 1st off-diagonal column number
         k = k + 1
         val[k] = 2nd off-diagonal, bindx[k] = 2nd off-diagonal column number
         etc

   c) put the diagonal element of the new row in  val[j]

   d) store free space pointer in bindx[j+1] (i.e. bindx[j+1] = k).


This program should produce approximately the following iteration output:

 
                *******************************************************
                ***** Preconditioned GMRES solution
                ***** No preconditioning
                ***** No scaling
                *******************************************************
 
                iter:    0              residual = 1.000000e+00
                iter:    1              residual = 7.141428e-01
                iter:    2              residual = 1.687498e-01
                iter:    3              residual = 2.119830e-02
                iter:    4              residual = 1.928932e-16

---


Problem 3: 
=========
IMPORTANT: COPY THE FILE 'original.c' INTO 'az_simple.c'. YOU MIGHT WANT 
TO SAVE 'az_simple.c' BEFORE DOING THIS.

The original sample program uses the GMRES algorithm as this is the default 
AZTEC method (indicated by setting options[AZ_solver] in AZ_defaults). Change
the sample program so that we use the TFQMR method and so that the algorithm
terminates when the initial residual is reduced by 10^5 (instead of the 
default 10^6).  See the "Aztec Options" section of the Aztec User's Guide for 
more information.
Note: this example is just for demonstration purposes as we should really use
the conjugate gradient algorithm for this symmetric problem.

The  resulting iteration output of the program should now approximately be:


                *******************************************************
                ***** Preconditioned TFQMR solution
                ***** No preconditioning
                ***** No scaling
                *******************************************************
 
                iter:    0              residual = 1.000000e+00
                iter:    1              residual = 3.078276e-01
                iter:    2              residual = 1.352989e-01
                iter:    3              residual = 7.202456e-02
                iter:    4              residual = 4.273759e-02
                iter:    5              residual = 2.571415e-02
                iter:    6              residual = 1.391762e-02
                iter:    7              residual = 6.317909e-03
                iter:    8              residual = 2.292283e-03
                iter:    9              residual = 6.648821e-04
                iter:   10              residual = 1.506405e-04
                iter:   11              residual = 1.590716e-05
                iter:   12              residual = 9.021697e-07
 
---
 
Problem 4: 
=========
Currently, the grid size parameter, n (for an n x n grid), is fixed.
To make a grid size parameter that the user can input, one processor
must read the input and then broadcast the value.  Using the function 
AZ_broadcast(), add the lines necessary to have processor 0 (node name 
is given by proc_config[AZ_node]) read the grid size parameter from the 
user and broadcast the information to the other processors. See the 
AZ_broadcast() description in the Aztec User's Guide for more information.

If the program is run and the value 7 is given as input (for a 
7 x 7 grid), the  resulting iteration output should approximately be:

                *******************************************************
                ***** Preconditioned TFQMR solution
                ***** No preconditioning
                ***** No scaling
                *******************************************************
 
                iter:    0              residual = 1.000000e+00
                iter:    1              residual = 3.078276e-01
                iter:    2              residual = 1.352989e-01
                iter:    3              residual = 7.203379e-02
                iter:    4              residual = 4.316646e-02
                iter:    5              residual = 2.765714e-02
                iter:    6              residual = 1.777434e-02
                iter:    7              residual = 1.055632e-02
                iter:    8              residual = 5.501200e-03
                iter:    9              residual = 2.430743e-03
                iter:   10              residual = 8.779539e-04
                iter:   11              residual = 2.893932e-04
                iter:   12              residual = 7.050597e-05
                iter:   13              residual = 1.091404e-05
                iter:   14              residual = 7.701444e-07
---

IMPORTANT: SAVE THIS PROGRAM IN THE FILE 'principal.c'.

Problem 5:
==========
Change the right hand side so that there is a '1' in each of the four
corners of the grid and a '0' everywhere else.

Note: The global right hand side vector 'B' needs to be distributed over 
the processors. That is, the specific element B[k] is stored on only 1 
processor.  The function AZ_transform() permutes the matrix such that the 
element B[k] must be stored in b[update_index[i]] on the processor for which 
there exists an i (0 <= i < N_update) such that update[i] = k.

If this program is run using the value 7 as input, the resulting iteration
output should approximately be:

                *******************************************************
                ***** Preconditioned TFQMR solution
                ***** No preconditioning
                ***** No scaling
                *******************************************************
 
                iter:    0              residual = 1.000000e+00
                iter:    1              residual = 3.078276e-01
                iter:    2              residual = 1.464818e-01
                iter:    3              residual = 9.497719e-02
                iter:    4              residual = 6.810138e-02
                iter:    5              residual = 4.444184e-02
                iter:    6              residual = 2.311353e-02
                iter:    7              residual = 3.528172e-03
                iter:    8              residual = 3.851591e-04
                iter:    9              residual = 1.561198e-17

---

Problem 6
=========
In some cases, we wish to initialize the right hand side vector at 
the same time that we initialize the matrix (ie. before AZ_transform()). 
Unfortunately, the array 'update_index' (used in the previous exercise) 
is only available after the AZ_transform() call. Instead of using the
array 'update_index', the global right hand side element B[k] can be 
stored as element tmp_b[i] on the processor for which there exists an 
i (0 <= i < N_update) such that update[i] = k. After AZ_transform() the 
tmp_b elements can be moved into their proper b[update_index[i]] location.

Change the sample program so that the right hand side is initialized
at the same time as the matrix. Then, after AZ_transform() is invoked
permute the right hand side so that it matches the matrix permutation
done in AZ_tranform().

If this program is run using the value 7 as input, the resulting output 
should be the same as for Problem 5.

Problem 7:
==========
Modify the program so that after solving the system in Problem 6 it
zeros out the 1's in the 2 right corners of the right hand side, and
solves the system again using the previous solution as an initial guess.
Use the function AZ_find_index() to determine the location in 'update' 
of the points 'n-1' and 'n*n-1'.

If this program is run using the value 7 as input, the resulting 
iteration output should approximately be:


                *******************************************************
                ***** Preconditioned TFQMR solution
                ***** No preconditioning
                ***** No scaling
                *******************************************************
 
                iter:    0              residual = 1.000000e+00
                iter:    1              residual = 3.078276e-01
                iter:    2              residual = 1.464818e-01
                iter:    3              residual = 9.497719e-02
                iter:    4              residual = 6.810138e-02
                iter:    5              residual = 4.444184e-02
                iter:    6              residual = 2.311353e-02
                iter:    7              residual = 3.528172e-03
                iter:    8              residual = 3.851591e-04
                iter:    9              residual = 1.561198e-17
 

                *******************************************************
                ***** Preconditioned TFQMR solution
                ***** No preconditioning
                ***** No scaling
                *******************************************************
 
                iter:    0              residual = 1.000000e+00
                iter:    1              residual = 3.078276e-01
                iter:    2              residual = 1.411253e-01
                iter:    3              residual = 8.361324e-02
                iter:    4              residual = 5.469282e-02
                iter:    5              residual = 3.524117e-02
                iter:    6              residual = 2.006837e-02
                iter:    7              residual = 1.048266e-02
                iter:    8              residual = 5.623542e-03
                iter:    9              residual = 2.611812e-03
                iter:   10              residual = 8.182422e-04
                iter:   11              residual = 1.897014e-04
                iter:   12              residual = 3.757968e-05
                iter:   13              residual = 6.296418e-07


Problem 8
=========
There might also arise cases where we wish to modify a matrix 
which has already been permuted by AZ_transform(). In this case
we must use 'update_index' and 'extern_index' to determine where
matrix values are stored.

Write a new routine called 'post_add_row()' which overwrites the
AZ_transform'ed matrix in between the 2 AZ_solve() calls in Problem 7.
The matrix modification will only be applied to rows corresponding
to grid points on the right boundary of the domain. Change the 
stencil at these boundary rows from 
             -1
         -1   4          to          -1  1.
             -1

Note: This exercise can be a bit tricky. The idea is to use AZ_find_index()
on 'update' and/or on 'external' to find the location of the left
neighbor. The stencil value for this neighbor is to be kept as -1.
For all other neighbors, the stencil value is changed to 0.

IMPORTANT: AZ_find_index() can not be used on 'update_index' and
'extern_index' as these are not in ascending order.

If this program is run using the value 7 as input, the resulting iteration
output should approximately be:

                *******************************************************
                ***** Preconditioned TFQMR solution
                ***** No preconditioning
                ***** No scaling
                *******************************************************
 
                iter:    0              residual = 1.000000e+00
                iter:    1              residual = 3.078276e-01
                iter:    2              residual = 1.464818e-01
                iter:    3              residual = 9.497719e-02
                iter:    4              residual = 6.810138e-02
                iter:    5              residual = 4.444184e-02
                iter:    6              residual = 2.311353e-02
                iter:    7              residual = 3.528172e-03
                iter:    8              residual = 3.851591e-04
                iter:    9              residual = 1.561198e-17
 

                *******************************************************
                ***** Preconditioned TFQMR solution
                ***** No preconditioning
                ***** No scaling
                *******************************************************
 
                iter:    0              residual = 1.000000e+00
                iter:    1              residual = 1.462427e+00
                iter:    2              residual = 1.574105e+00
                iter:    3              residual = 1.270515e+00
                iter:    4              residual = 1.094866e+00
                iter:    5              residual = 1.077147e+00
                iter:    6              residual = 1.038635e+00
                iter:    7              residual = 8.276535e-01
                iter:    8              residual = 6.019309e-01
                iter:    9              residual = 4.498290e-01
                iter:   10              residual = 1.996331e-01
                iter:   11              residual = 6.072724e-02
                iter:   12              residual = 2.070181e-02
                iter:   13              residual = 8.442455e-04
                iter:   14              residual = 5.841776e-04
                iter:   15              residual = 3.081943e-04
                iter:   16              residual = 7.862072e-05
                iter:   17              residual = 3.015537e-05
                iter:   18              residual = 1.175332e-06

Problem 9:
==========
IMPORTANT: COPY THE FILE 'principal.c' INTO 'az_simple.c'. YOU MIGHT WANT 
TO SAVE 'az_simple.c' BEFORE DOING THIS.

Change this program so that we can handle fairly arbitrary 2D regions.
In particular, the user will input the number of horizontal lines in
the grid as the parameter 'n'. He will also supply two integer 
returning functions: left() and right(). left(i) returns the starting
x value in the ith horizontal line. right(i) returns the ending x 
value in the ith horizontal line.

For example, the functions

int left(int n)
{
  return(0);
}
 
int right(int n)
{
  if (n == 0) return(3);
  if (n == 1) return(2);
  if (n == 2) return(1);
  if (n == 3) return(2);
  else return(7);
}

used on a problem with 4 horizontal lines corresponds to the grid 

               9  10  11
               7   8 
               4   5   6
               0   1   2   3

with Poisson matrix

               4  -1   0   0  -1   0   0   0   0   0   0   0
              -1   4  -1   0   0  -1   0   0   0   0   0   0
               0  -1   4  -1   0   0  -1   0   0   0   0   0
               0   0  -1   4   0   0   0   0   0   0   0   0
              -1   0   0   0   4  -1   0  -1   0   0   0   0
               0  -1   0   0  -1   4  -1   0  -1   0   0   0
               0   0  -1   0   0  -1   4   0   0   0   0   0
               0   0   0   0  -1   0   0   4  -1  -1   0   0
               0   0   0   0   0  -1   0  -1   4   0  -1   0
               0   0   0   0   0   0   0  -1   0   4  -1   0
               0   0   0   0   0   0   0   0  -1  -1   4  -1  
               0   0   0   0   0   0   0   0   0   0  -1   4 

Running this problem with the same initial guess (x = 0) and 
right hand side (b = e_1, where e_1 is the vector of all zeros 
except for the first element which is 1) should approximately 
produce the iteration output:

                *******************************************************
                ***** Preconditioned TFQMR solution
                ***** No preconditioning
                ***** No scaling
                *******************************************************
 
                iter:    0              residual = 1.000000e+00
                iter:    1              residual = 3.078276e-01
                iter:    2              residual = 1.212586e-01
                iter:    3              residual = 3.382271e-02
                iter:    4              residual = 5.095646e-03
                iter:    5              residual = 1.262783e-03
                iter:    6              residual = 1.029025e-04
                iter:    7              residual = 1.146834e-05
                iter:    8              residual = 6.605168e-09

---

Problem 10:
=========
IMPORTANT: COPY THE FILE 'principal.c' (created in Problem 4) INTO 
'az_simple.c'. YOU MIGHT WANT TO SAVE 'az_simple.c' BEFORE DOING THIS.

Change this program from a 2D Poisson approximation on the n x n square 
to a 3D Poisson approximation on the n x n x n cube. Run this problem
with the same initial guess (x = 0) and right hand side (B = e_1)

NOTE: Remember to allocate enough memory for 'bindx' and 'val' to 
accomodate the 7 point stencil.

If this program is run using the value 7 as input, the resulting 
iteration output should approximately be:


                *******************************************************
                ***** Preconditioned TFQMR solution
                ***** No preconditioning
                ***** No scaling
                *******************************************************
 
                iter:    0              residual = 1.000000e+00
                iter:    1              residual = 2.193551e-01
                iter:    2              residual = 7.539287e-02
                iter:    3              residual = 3.318523e-02
                iter:    4              residual = 1.690645e-02
                iter:    5              residual = 9.507550e-03
                iter:    6              residual = 5.724587e-03
                iter:    7              residual = 3.588558e-03
                iter:    8              residual = 2.265129e-03
                iter:    9              residual = 1.380014e-03
                iter:   10              residual = 7.732288e-04
                iter:   11              residual = 3.832266e-04
                iter:   12              residual = 1.652267e-04
                iter:   13              residual = 6.181623e-05
                iter:   14              residual = 2.009490e-05
                iter:   15              residual = 1.346214e-06


Problem 11:
==========
Change the 3D Poisson operator to approximate the system of 
m coupled PDE equations on an n x n x n grid:

Pois( u^(0) ) + .1    sum    Pois( u^(i) )  = f^0
                  0 <= i  < m 
                    i != 0

Pois( u^(1) ) + .1    sum    Pois( u^(i) )  = f^1
                  0 <= i  < m 
                    i != 1


                       .
                       .
                       .
Pois( u^(m-1) ) + .1    sum    Pois( u^(i) )  = f^(m-1)
                  0 <= i  < m 
                    i != m-1

where Pois(v) = v_xx + v_yy + v_zz.

Use the VBR format and let the value of m be a global variable
input by the user. Run this program with the same initial guess
(x = 0) and the same combined right hand side (B = e_1, that is 
f^0 = e_1, f^1 = 0, f^2 = 0, ..., f^(m-1) = 0).

Hint: The m x m diagonal blocks of this matrix should consist of 
the value 6. on the diagonal entries and the value .6 on all the 
off-diagonals entries.  The m x m off-diagonal blocks of this 
matrix should consist of the value -1. on the diagonal entries and 
the value -.1 on all the off diagonals entries.

If this program is run with 7 and 3 as input (i.e. a system of
3 coupled PDEs on a 7 x 7 x 7 grid), the iteration output should
approximately be:

                *******************************************************
                ***** Preconditioned TFQMR solution
                ***** No preconditioning
                ***** No scaling
                *******************************************************
 
                iter:    0              residual = 1.000000e+00
                iter:    1              residual = 2.885746e-01
                iter:    2              residual = 1.241962e-01
                iter:    3              residual = 6.121277e-02
                iter:    4              residual = 3.385888e-02
                iter:    5              residual = 2.037280e-02
                iter:    6              residual = 1.293223e-02
                iter:    7              residual = 8.521449e-03
                iter:    8              residual = 5.685374e-03
                iter:    9              residual = 3.711614e-03
                iter:   10              residual = 2.284157e-03
                iter:   11              residual = 1.284914e-03
                iter:   12              residual = 6.570774e-04
                iter:   13              residual = 3.102746e-04
                iter:   14              residual = 1.369291e-04
                iter:   15              residual = 5.682475e-05
                iter:   16              residual = 6.471154e-06


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                     Answers to exercises:
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   
Problem 1:
=========
Change line 48 to 
 48    AZ_read_update(&N_update,&update,proc_config,n*n,1,AZ_file);

Create the file .update. To run on 4 processors, this file should
contain the following information:

   9
 3  7 11 15 19 23 27 31 35
   9
 2  6 10 14 18 22 26 30 34
   9
 1  5  9 13 17 21 25 29 33
   9
 0  4  8 12 16 20 24 28 32


To run on 1 processor, this file should contain:

   36
 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 
22 23 24 25 26 27 28 29 30 31 32 33 34 35

Problem 2:
=========
Change line 48 to 
 48    AZ_read_update(&N_update,&update,proc_config,4,1,AZ_linear);

The uncommented new add_row() routine should resemble: 

void add_row(int row,int location,double val[], int bindx[])
{
   int k;
 
   k = bindx[location];
   if (row == 0) {
      bindx[k] = 1;   val[k++] = 3;
      bindx[k] = 2;   val[k++] = 2;
      bindx[k] = 3;   val[k++] = 1;
                      val[location] = 7.;
   }
   else if (row == 1) {
      bindx[k] = 0;   val[k++] = 5;
      bindx[k] = 2;   val[k++] = 3;
      bindx[k] = 3;   val[k++] = 1;
                      val[location] = 8.;
   }
   else if (row == 2) {
      bindx[k] = 0;   val[k++] = 5;
      bindx[k] = 1;   val[k++] = 3;
      bindx[k] = 3;   val[k++] = 2;
                      val[location] = 9.;
   }
   else if (row == 3) {
      bindx[k] = 0;   val[k++] = 1;
      bindx[k] = 1;   val[k++] = 2;
      bindx[k] = 2;   val[k++] = 1;
                      val[location] = 6.;
   }
   else perror("Invalid row number");
   bindx[location+1] = k;
}

Problem 3: 
=========
After line 69 add:

 69a   options[AZ_solver] = AZ_tfqmr;
 69b   params[AZ_tol]     = 1.0e-5;

Problem 4: 
=========
After line 45 (corresponding to original program listing) add:

 45a   if (proc_config[AZ_node] == 0) {
 45b      printf("Enter grid size (n, for n x n grid)\n");
 45c      scanf("%d",&n);
 45d   }
 45e   AZ_broadcast((char *) &n, sizeof(int), proc_config, AZ_PACK);
 45f   AZ_broadcast(NULL       ,           0, proc_config, AZ_SEND);

and enter the value 7 when prompted for the grid size.
   
Problem 5: 
=========
Change line 71 (corresponding to original program listing) to 

 71   /* Set rhs (delta function at grid corners) and initialize guess */

After line 80 (corresponding to original program listing) add:

 80a    if (update[i] == n-1  ) b[update_index[i]] = 1.0;
 80b    if (update[i] == n*n-n) b[update_index[i]] = 1.0;
 80c    if (update[i] == n*n-1) b[update_index[i]] = 1.0;

Alternatively, b can be assigned via 

        if (update[i] == 0    ) b[i] = 1.0;
        if (update[i] == n-1  ) b[i] = 1.0;
        if (update[i] == n*n-n) b[i] = 1.0;
        if (update[i] == n*n-1) b[i] = 1.0;
and AZ_reorder_vec() could be invoked after the loop to
reorder b so that it corresponds to the transformed system.

Problem 6:
==========
In our solution, we added a new declaration

 36a   double *tmp_b;

After line 52 (corresponding to original program listing) we added:

 52a   tmp_b   = (double *) calloc(N_update,sizeof(double));

After line 59 (corresponding to original program listing) we added:

 59a      tmp_b[i] = 0.0;
 59b      if (update[i] == 0    ) tmp_b[i] = 1.0;
 59c      if (update[i] == n-1  ) tmp_b[i] = 1.0;
 59d      if (update[i] == n*n-n) tmp_b[i] = 1.0;
 59e      if (update[i] == n*n-1) tmp_b[i] = 1.0;

and replaced

 79     b[update_index[i]] = 0.0;
 80     if (update[i] == 0    ) b[update_index[i]] = 1.0;
 80a    if (update[i] == n-1  ) b[update_index[i]] = 1.0;
 80b    if (update[i] == n*n-n) b[update_index[i]] = 1.0;
 80c    if (update[i] == n*n-1) b[update_index[i]] = 1.0;

by 

 79     b[update_index[i]] = tmp_b[i];

Finally, after line 87, we added:

 87a   free(tmp_b);

Problem 7:
==========
After line 86 (corresponding to original program listing), add:

 86a
 86b   i = AZ_find_index(  n-1, update, N_update);
 86c   if (i != -1) b[update_index[i]] = 0.0;
 86d   i = AZ_find_index(n*n-1, update, N_update);
 86e   if (i != -1) b[update_index[i]] = 0.0;
 86f
 86g   AZ_solve(x,b, options, params, NULL,bindx,NULL,NULL,NULL,val,
 86h          data_org, status, proc_config);

Note: when solving the same system mulitple times with different right 
hand sides, it is possible to reuse factorization information produced 
by the matrix scaling options and some of the preconditioners (AZ_ilu, 
AZ_lu, AZ_bilu). To do this, set options[AZ_pre_calc] to AZ_reuse
after the first solve AZ_solve().
   
Problem 8:
=========
We declared a new external function 

 21a   extern void post_add_row_5pt(int row, int location, double val[], 
 21b                     int bindx[], int update[], int update_index[], 
 21c                     int external[], int extern_index[], int data_org[]);

and added the following lines just before the second call to AZ_solve().

 86f1  for (i = 0 ; i < N_update ; i++ ) {
 86f2     if (update[i]%n == n-1) 
 86f3        post_add_row_5pt(update[i],update_index[i],val,bindx, update, 
 86f4                       update_index, external, extern_index, data_org);
 86f5  }
 86f6

The uncommented new subroutine follows:
    
    void post_add_row_5pt(int row, int location, double val[], int bindx[],
                        int update[], int update_index[], int external[],
                        int extern_index[], int data_org[])
    {
       int i, k, neighbor = -1;
 
       if (row%n != 0) {
          i = AZ_find_index(row-1, update, data_org[AZ_N_internal] +
                                       data_org[AZ_N_border]);
          if (i == -1) {
             i = AZ_find_index(row-1, external, data_org[AZ_N_external]);
             if (i != -1) neighbor = extern_index[i];
          }
          else neighbor = update_index[i];
       }
 
       for (k = bindx[location] ; k < bindx[location+1] ; k++ )
          if (bindx[k] != neighbor) val[k] = 0.;
 
       val[location]     = 1.; /* matrix diagonal */
    }


Problem 9:
=========
In addition to the functions left() and right() given in the problem
it is necessary to make the following changes.

Replace 

 21    extern void add_row(int row,int i,double val[],int bindx[]);

by

 21    extern void add_row(int row,int location,double val[],int bindx[],
 21a                      int yline_head, int yval,int n);
 21b   extern int left(int yval); 
 21c   extern int right(int yval);
 21d   int    yval, yline_head, next;

Replace

 45b      printf("Enter grid size (n, for n x n grid)\n");

by 

 45b      printf("Enter grid size (n, n horizontal lines in grid)\n");

Replace

 48    AZ_read_update(&N_update,&update,proc_config,n*n,1,AZ_linear);

by

 48    total = 0;   /* total is set to the total number of grid points */
 48a   for (i = 0 ; i < n ; i++ ) { total += (right(i) - left(i)+1);}
 48b   AZ_read_update(&N_update,&update,proc_config,total,1,AZ_linear);

Replace

 58    for (i = 0 ; i < N_update ; i++ ) {
 59       add_row(update[i],i,val,bindx);
 60    }

by 

 58    yval     = 0;   yline_head = 0;
 59    next     = right(0) - left(0) + 1;
 60    for (i = 0 ; i < N_update ; i++ ) {
 60a      while ( next <= update[i] ) {
 60b         yline_head = next;   yval++;
 60c         next = yline_head + right(yval) - left(yval) + 1;
 60d      }
 60e      add_row(update[i],i,val,bindx,yline_head,yval,n);
 60f   }

and add the subroutine add_row():

void add_row(int row,int location,double val[],int bindx[],
             int yline_head, int yval,int n)
{
/* Add one row to an MSR matrix corresponding to a discrete approximation
 * on an irregular 2D domain. Specifically, the grid contains n horizontal
 * lines. The x values on line j start at left(j) and end at right(j).
 *
 * Parameters:
 *    row          == global row number of the new row to be added.
 *    location     == local row where diagonal of the new row will be stored.
 *    val,bindx    == (see user's guide). On output, val[] and bindx[]
 *                    are appended such that the new row has been added.
 *    yline_head   == global row number of the first grid point in the
 *                    horizontal line containing 'row'.
 *    yval         == horizontal line y = yval contains 'row'.
 *    n            == total number of horizontal lines in grid.
 */
   int b_neigh = 0, t_neigh = 0, l_neigh = 0, r_neigh = 0;
   int lval0 = 0, rval1 = 0, lval2 = 0, rval2 = 0, lval3 = 0, rval3 = 0;
   extern int left(), right();
   int normalized, k;
 
   normalized = yline_head - left(yval);
   l_neigh    = row-1;   lval0 = normalized +  left(yval) + 1;
   r_neigh    = row+1;   rval1 = normalized + right(yval) - 1;
 
   if (yval != 0) {
      b_neigh = row+left(yval)-right(yval-1)-1;
      lval2   = normalized +  left(yval-1);
      rval2   = normalized + right(yval-1);
   }
   else rval2 = lval2 - 1;
   if (yval != n-1) {
      t_neigh = row-left(yval+1)+right(yval)+1;
      lval3   = normalized +  left(yval+1);
      rval3   = normalized + right(yval+1);
   }
   else rval3 = lval3 - 1;
 
   /* check neighbors in each direction and add nonzero if neighbor exits */

   k = bindx[location];
   bindx[k] = l_neigh; if  (row >= lval0)                    val[k++] = -1.;
   bindx[k] = r_neigh; if  (row <= rval1)                    val[k++] = -1.;
   bindx[k] = b_neigh; if ((row >= lval2) && (row <= rval2)) val[k++] = -1.;
   bindx[k] = t_neigh; if ((row >= lval3) && (row <= rval3)) val[k++] = -1.;
   bindx[location+1] = k;  val[location]     = 4.; /* matrix diagonal */
}
  
Problem 10:
==========
Change line 45b in Problem 4 program to 

 45b      printf("Enter grid size (n, for n x n x n grid)\n");

Change line 48 in Problem 4 program to 

 48    AZ_read_update(&N_update,&update,proc_config,n*n*n,1,AZ_linear);

Change lines 53 and 54 to increase the storage:

 53    bindx   = (int    *) calloc(N_update*7+1,sizeof(int));
 54    val     = (double *) calloc(N_update*7+1,sizeof(double));

Change line 99 to 

 99  * to the 3D Poisson operator on an n x n x n square.

After line 115, add the following lines:

115a   bindx[k]  = row + n*n; if ((row/(n*n))%n != n-1) val[k++] = -1.;
115b   bindx[k]  = row - n*n; if ((row/(n*n))%n !=   0) val[k++] = -1.;

and finally change the matrix diagonal in line 117 to 

117    bindx[location+1] = k;  val[location]     = 6.; /* matrix diagonal */

Problem 11:
==========
Our new program is as follows:

/* This software was developed at Sandia National Labs under US Energy Dept.
 * contract DE-AC-4-76DP00789 and is copyrighted by Sandia Corporation.  */

#include <stdio.h>
#include <stdlib.h>
#ifdef MPI
#include <mpi.h>
#endif
#include "az_aztec.h"
#define perror(str) { fprintf(stderr,"%s\n",str);   exit(-1); }

int m, n = 6;      /* EQUATIONS WILL BE SOLVED ON an n x n x n GRID. */

void main(int argc, char *argv[])

/* Set up a coupled PDE test problem and solve it with AZTEC.                */

{
   double *b,*x;                    /* rhs and approximate solution          */
   int    i, j;
   extern void add_row(int row,int location, int rpntr[],int bpntr[],
			int bindx[], int indx[],double val[]);

            /* See Aztec User's Guide for the variables that follow:         */
                               
   int    proc_config[AZ_PROC_SIZE];/* Processor information.                */
   int    options[AZ_OPTIONS_SIZE]; /* Array used to select solver options.  */
   double params[AZ_PARAMS_SIZE];   /* User selected solver paramters.       */
   int    *data_org;                /* Array to specify data layout          */
   double status[AZ_STATUS_SIZE];   /* Information returned from AZ_solve(). */
   int    *update,                  /* vector elements updated on this node. */
          *external;                /* vector elements needed by this node.  */
   int    *update_index;            /* ordering of update[] and external[]   */
   int    *extern_index;            /* locally on this processor.            */
   int    *bindx;                   /* Sparse matrix to be solved is stored  */
   double *val;                     /* in these MSR arrays.                  */
   int    *indx,*cpntr,*bpntr,*rpntr;
   int    N_update;                 /* # of unknowns updated on this node    */

#ifdef MPI
   MPI_Init(&argc,&argv);
#endif

   /* get number of processors and the name of this processor */

   AZ_processor_info(proc_config);

   if (proc_config[AZ_node] == 0) {
      printf("Enter grid size (n, for n x n x n grid)\n");
      scanf("%d",&n);
      printf("Enter number of PDEs\n");
      scanf("%d",&m);
   }
   AZ_broadcast((char *) &n, sizeof(int), proc_config, AZ_PACK);
   AZ_broadcast((char *) &m, sizeof(int), proc_config, AZ_PACK);
   AZ_broadcast(NULL       ,           0, proc_config, AZ_SEND);

   /* Define partitioning:matrix rows (ascending order) owned by this node */

   AZ_read_update(&N_update,&update,proc_config,n*n*n,1,AZ_linear);

   /* create the matrix: each processor creates only rows  */
   /* appearing in update[] (using global col. numbers).   */

   rpntr   = (int    *) calloc(N_update+1,sizeof(int));
   bpntr   = (int    *) calloc(N_update+1,sizeof(int));
   bindx   = (int    *) calloc(N_update*7+1,sizeof(int));
   indx    = (int    *) calloc(N_update*7+1,sizeof(int));
   val     = (double *) calloc(m*m*N_update*7+1,sizeof(double));
   if (val == NULL) perror("Error: Not enough space to create matrix")

   rpntr[0] = 0; bpntr[0] = 0; indx[0]  = 0;
   for (i = 0 ; i < N_update ; i++ ) {
      add_row(update[i],i,rpntr,bpntr,bindx,indx,val);
   }

   /* convert matrix to a local distributed matrix */

   AZ_transform(proc_config,&external,bindx,val,update,&update_index,
        &extern_index,&data_org,N_update,indx,bpntr,rpntr,&cpntr,AZ_VBR_MATRIX);

   /* initialize AZTEC options */

   AZ_defaults(options, params);
   options[AZ_solver] = AZ_tfqmr;
   params[AZ_tol]     = 1.0e-5;

  /* Set rhs (delta function at lower left corner) and initialize guess */

  b = (double *) calloc(m*N_update,sizeof(double));
  x = (double *) calloc(m*N_update + data_org[AZ_N_external],sizeof(double));
  if ((x == NULL) && (i != 0)) perror("Not enough space in rhs")

  for (i=0 ; i < N_update; i++ ) { 
    for (j = 0 ; j < m ; j++ ) {
       x[m*update_index[i]+j] = 0.0;
       b[m*update_index[i]+j] = 0.0;
    }
    if (update[i] == 0 ) b[m*update_index[i]] = 1.0;
  }

  /* solve the system of equations using b  as the right hand side */

   AZ_solve(x,b, options, params, indx,bindx,rpntr,cpntr,bpntr,val,
	    data_org, status, proc_config);

#ifdef MPI
   MPI_Finalize();
#endif
}

/***************************************************************************/
/***************************************************************************/

void add_row(int row,int location, int rpntr[],int bpntr[],int bindx[],
	int indx[],double val[])
{
/* Add one row to an MSR matrix corresponding to a discrete approximation
 * to the 3D Poisson operator on an n x n x n square.
 *
 * Parameters:
 *    row          == global row number of the new row to be added.
 *    location     == local row where diagonal of the new row will be stored.
 *    val,bindx    == (see user's guide). On output, val[] and bindx[] 
 *                    are appended such that the new row has been added.
 */
   int k;
   extern void VBR_block(int indx[],int *k,double val[],double factor);

   /* check neighbors in each direction and add nonzero if neighbor exits */

   rpntr[location+1] = rpntr[location] + m;

   k = bpntr[location];
   bindx[k]  = row;                                 VBR_block(indx,&k,val, 6.);
   bindx[k]  = row + 1;   if ((row  )%n != n-1)     VBR_block(indx,&k,val,-1.);
   bindx[k]  = row - 1;   if ((row  )%n !=   0)     VBR_block(indx,&k,val,-1.);
   bindx[k]  = row + n;   if ((row/n)%n != n-1)     VBR_block(indx,&k,val,-1.);
   bindx[k]  = row - n;   if ((row/n)%n !=   0)     VBR_block(indx,&k,val,-1.);
   bindx[k]  = row + n*n; if ((row/(n*n))%n != n-1) VBR_block(indx,&k,val,-1.);
   bindx[k]  = row - n*n; if ((row/(n*n))%n !=   0) VBR_block(indx,&k,val,-1.);

   bpntr[location+1] = k; 
}

void VBR_block(int indx[],int *k,double val[],double factor)
{
   int i,j,indx_ptr;

   indx_ptr = indx[*k];
   indx[*k+1] = indx_ptr + m*m;  
   for (i = 0 ; i < m ; i++ ) {
     for (j = 0 ; j < m ; j++ ) {
        if (i == j) val[indx_ptr++] = factor;
	else val[indx_ptr++] = factor * .1;
     }
   }
   (*k)++;
}

All the necessary changes include:
  1) new declarations (m,j,*indx,*cpntr,*bpntr,*rpntr)
  2) changes in the add_row(), AZ_transform(), and AZ_solve() parameters
  3) adding 3 lines to input m and broadcast it.
  4) storage allocation for val,rpntr,bpntr,indx,val,b and x
  5) initializing rpntr[0], bpntr[0], indx[0] to 0
  6) changing the right hand side and initial guess for VBR format
  7) changing add_row() to call VBR_block instead of setting val[].
  8) adding the subroutine VBR_block()
